<?xml version="1.0" encoding="UTF-8"?>
<chapter id="events">
    <title>Events</title>
    
    <para>Beans may produce and consume events. This facility allows beans to interact 
    in a completely decoupled fashion, with no compile-time dependency between the 
    interacting beans. Most importantly, it allows stateful beans in one architectural  
    tier of the application to synchronize their internal state with state changes that 
    occur in a different tier.</para>
    
    <para>An event comprises:</para>
    
    <itemizedlist>
      <listitem>
        <para>A Java object&mdash;the <emphasis>event object</emphasis></para>
      </listitem>
      <listitem>
        <para>A set of instances of qualifier types&mdash;the 
        <emphasis>event qualifiers</emphasis></para>
      </listitem>
    </itemizedlist>
    
    <para>The event object acts as a payload, to propagate state from producer to consumer.
    The event qualifiers act as topic selectors, allowing the consumer to narrow the set of
    events it observes.</para>
    
    <para>An <emphasis>observer method</emphasis> acts as event consumer, observing events 
    of a specific type&mdash;the <emphasis>observed event type</emphasis>&mdash;with a 
    specific set of qualifiers&mdash;the <emphasis>observed event qualifiers</emphasis>. 
    An observer  method will be notified of an event if the event object is assignable to
    the observed event type, and if all the observed event qualifiers are event qualifiers 
    of the event.</para>
    
    <section>
      <title>Event types and qualifier types</title>
      
      <para>An event object is an instance of a concrete Java class with no type
      variables. The <emphasis>event types</emphasis> of the event include all 
      superclasses and interfaces of the runtime class of the event object.</para>
      
      <para>An event type may not contain a type variable.</para>
            
      <para>An event qualifier type is just an ordinary qualifier type as specified in 
      <xref linkend="definingqualifiertypes"/>, typically defined as 
      <literal>@Target({METHOD, FIELD, PARAMETER, TYPE})</literal> or
      <literal>@Target({FIELD, PARAMETER})</literal>.</para>
      
      <para>Every event has the qualifier <literal>@javax.enterprise.inject.Any</literal>,
      even if it does not explicitly declare this qualifier.</para>
      
      <para>Any Java type may be an observed event type.</para>
    
    </section>
    
    <section id="observerresolution">
      <title>Observer resolution</title>
      
      <para>The process of matching an event to its observer methods is called 
      <emphasis>observer resolution</emphasis>. The container considers event type and 
      qualifiers when resolving observers.</para>

      <para>Observer resolution usually occurs at runtime.</para>

      <para>An event is delivered to an observer method if:</para>
      
      <itemizedlist>
        <listitem>
          <para>The observer method belongs to an enabled bean.</para>
        </listitem>
        <listitem>
          <para>The event object is assignable to the observed event type, taking type 
          parameters into consideration.</para>
        </listitem>
        <listitem>
          <para>The observer method has no event qualifiers or has a subset of the event 
	      qualifiers. An observer method has an event qualifier if it has an observed event 
	      qualifier with (a) the same type and (b) the same annotation member value for each 
	      member which is not annotated <literal>@javax.enterprise.util.Nonbinding</literal>.</para>
        </listitem>
        <listitem>
          <para>Either the event is not a container lifecycle event, as defined in 
          <xref linkend="initevents"/>, or the observer method belongs to an 
          extension.</para>
        </listitem>
      </itemizedlist>
      
      <para>If the runtime type of the event object contains a type variable, the 
      container must throw an <literal>IllegalArgumentException</literal>.</para>
      
      <para>For a custom implementation of the <literal>ObserverMethod</literal>
      interface defined in <xref linkend="observermethod"/>, the container must
      call <literal>getObservedType()</literal> and <literal>getObservedQualifiers()</literal>
      to determine the observed event type and qualifiers.</para>
      
      <section>
        <title>Assignability of type variables, raw and parameterized types</title>
        
        <para>An event type is considered assignable to a type variable if the
        event type is assignable to the upper bound, if any.</para>

        <para>A parameterized event type is considered assignable to a raw observed
        event type if the raw types are identical.</para>
      
        <para>A parameterized event type is considered assignable to a parameterized  
        observed event type if they have identical raw type and for each parameter:</para>
      
        <itemizedlist>
          <listitem>
            <para>the observed event type parameter is an actual type with identical 
            raw type to the event type parameter, and, if the type is parameterized, 
            the event type parameter is assignable to the observed event type 
            parameter according to these rules, or</para>
          </listitem>
          <listitem>
            <para>the observed event type parameter is a wildcard and the event type
            parameter is assignable to the upper bound, if any, of the wildcard and 
            assignable from the lower bound, if any, of the wildcard, or</para>
          </listitem>
          <listitem>
            <para>the observed event type parameter is a type variable and the event 
            type parameter is assignable to the upper bound, if any, of the type 
            variable.</para>
          </listitem>
        </itemizedlist>
      
      </section>
      
      <section>
        <title>Event qualifier types with members</title>
        
        <para>As usual, the qualifier type may have annotation members:</para>
      
        <programlisting>@Qualifier
@Target(PARAMETER)
@Retention(RUNTIME)
public @interface Role {
    String value();
}</programlisting>
      
        <para>Consider the following event:</para> 
      
        <programlisting>public void login() {
    final User user = ...;
    loggedInEvent.fire( new LoggedInEvent(user), 
            new RoleQualifier() { public String value() { return user.getRole(); } );
}</programlisting>

        <para>Where <literal>RoleQualifier</literal> is an implementation of the qualifier 
        type <literal>Role</literal>:</para>
        
        <programlisting>public abstract class RoleQualifier 
        extends AnnotationLiteral&lt;Role&gt; 
        implements Role {}</programlisting> 
 
        <para>Then the following observer method will always be notified of the event:</para>
        
        <programlisting>public void afterLogin(@Observes LoggedInEvent event) { ... }</programlisting>
      
        <para>Whereas this observer method may or may not be notified, depending upon the
        value of <literal>user.getRole()</literal>:</para>

        <programlisting>public void afterAdminLogin(@Observes @Role("admin") LoggedInEvent event) { ... }</programlisting>
      
        <para>As usual, the container uses <literal>equals()</literal> to compare 
        event qualifier type member values.</para>
        
      </section>
      
      <section>
        <title>Multiple event qualifiers</title>
        
        <para>An event parameter may have multiple qualifiers.</para>
      
        <programlisting>public void afterDocumentUpdatedByAdmin(@Observes @Updated @ByAdmin Document doc) { ... }</programlisting>
      
        <para>Then this observer method will only be notified if all the observed event 
        qualifiers are specified when the event is fired:</para> 
      
        <programlisting>documentEvent.fire( document, new UpdatedQualifier() {}, new ByAdminQualifier() {} );</programlisting>
        
        <para>Other, less specific, observers will also be notified of this event:</para>
 
        <programlisting>public void afterDocumentUpdated(@Observes @Updated Document doc) { ... }</programlisting>
      
        <programlisting>public void afterDocumentEvent(@Observes Document doc) { ... }</programlisting>
      
      </section>
      
    </section>

    <section>
      <title>Firing events</title>
      
      <para>Beans fire events via an instance of the <literal>javax.enterprise.event.Event</literal> 
      interface, which may be injected:</para>
      
      <programlisting>@Inject @Any Event&lt;LoggedInEvent&gt; loggedInEvent;</programlisting>
      
      <para>The method <literal>fire()</literal> accepts an event object:</para>
      
      <programlisting>public void login() {
    ...
    loggedInEvent.fire( new LoggedInEvent(user) );
}</programlisting>

      <para>Any combination of qualifiers may be specified at the injection point:</para>
      
      <programlisting>@Inject @Admin Event&lt;LoggedInEvent&gt; adminLoggedInEvent;</programlisting>
      
      <para>Or, the <literal>@Any</literal> qualifier may be used, allowing the 
      application to specify qualifiers dynamically:</para>
      
      <programlisting>@Inject @Any Event&lt;LoggedInEvent&gt; loggedInEvent;
...
LoggedInEvent event = new LoggedInEvent(user);
if ( user.isAdmin() ) {
    loggedInEvent.select( new AdminQualifier() ).fire(event);
}
else {
    loggedInEvent.fire(event);
}</programlisting>
      
      <para>In this example, the event sometimes has the qualifier <literal>@Admin</literal>,
      depending upon the value of <literal>user.isAdmin()</literal>.</para>
      
      <section id="eventinterface">
        <title>The <literal>Event</literal> interface</title>

      <para>The <literal>Event</literal> interface provides a method for firing events
      with a specified combination of type and qualifiers:</para>
      
      <programlisting><![CDATA[public interface Event<T> {
      
    public void fire(T event);
      
    public Event<T> select(Annotation... qualifiers);
    public <U extends T> Event<U> select(Class<U> subtype, Annotation... qualifiers);
    public <U extends T> Event<U> select(TypeLiteral<U> subtype, Annotation... qualifiers);
      
}]]></programlisting>

       <para>For an injected <literal>Event</literal>:</para>
      
      <itemizedlist>
        <listitem>
          <para>the <emphasis>specified type</emphasis> is the type parameter specified 
          at the injection point, and</para>
        </listitem>
        <listitem>
          <para>the <emphasis>specified qualifiers</emphasis> are the qualifiers specified 
          at the injection point.</para>
        </listitem>
      </itemizedlist>

      <para>For example, this injected <literal>Event</literal> has specified type 
      <literal>LoggedInEvent</literal> and specified qualifier <literal>@Any</literal>:</para>
      
      <programlisting>@Inject @Any Event&lt;LoggedInEvent&gt; any;</programlisting>
      
      <para>The <literal>select()</literal> method returns a child <literal>Event</literal> 
      for a given specified type and additional specified qualifiers. If no specified type 
      is given, the specified type is the same as the parent.</para>
      
      <para>For example, this child <literal>Event</literal> has required type 
      <literal>AdminLoggedInEvent</literal> and additional specified qualifier 
      <literal>@Admin</literal>:</para>
      
      <programlisting>Event&lt;AdminLoggedInEvent&gt; admin = any.select( 
            AdminLoggedInEvent.class, 
            new AdminQualifier() );</programlisting>
      
      <para>If the specified type contains a type variable, an 
      <literal>IllegalArgumentException</literal> is thrown.</para>
      
      <para>If two instances of the same qualifier type are passed to 
      <literal>select()</literal>, an <literal>IllegalArgumentException</literal> 
      is thrown.</para>
      
      <para>If an instance of an annotation that is not a qualifier type is passed 
      to <literal>select()</literal>, an <literal>IllegalArgumentException</literal> 
      is thrown.</para>

      <para>The method <literal>fire()</literal> fires an event with the specified
      qualifiers and notifies observers, as defined by 
      <xref linkend="observernotification"/>.</para>
      
      <para>If the runtime type of the event object contains a type variable, an 
      <literal>IllegalArgumentException</literal> is thrown.</para>

      <para>If the runtime type of the event object is assignable to the type of a container 
      lifecycle event, <literal>IllegalArgumentException</literal> is thrown.</para>
      
      </section>
      
     <section>
        <title>The built-in <literal>Event</literal></title>

      <para>The container must provide a built-in bean with:</para>
      
      <itemizedlist>
        <listitem>
          <para><literal>Event&lt;X&gt;</literal> in its set of bean types, for every 
          Java type <literal>X</literal> that does not contain a type variable,</para>
       </listitem>
        <listitem>
          <para>every event qualifier type in its set of qualifier types,</para>
        </listitem>
        <listitem>
          <para>scope <literal>@Dependent</literal>,</para>
        </listitem>
        <listitem>
          <para>no bean name, and</para>
        </listitem>
        <listitem>
          <para>an implementation provided automatically by the container.</para>
        </listitem>
      </itemizedlist>

      <para>If an injection point of raw type <literal>Event</literal> is defined, the container 
      automatically detects the problem and treats it as a definition error.</para>
      
      <para>The built-in implementation must be a passivation capable dependency,
      as defined in <xref linkend="passivationcapabledependency"/>.</para>
      
     </section>
     
    </section>
        
    <section id="observermethods">
      <title>Observer methods</title>
      
      <para>An observer method allows the application to receive and respond to event 
      notifications.</para>
      
      <para>An observer method is a non-abstract method of a managed bean class or
      session bean class (or of an extension, as defined in <xref linkend="initevents"/>). 
      An observer method may be either static or non-static. If the bean is a session 
      bean, the observer method must be either a business method of the EJB or a static 
      method of the bean class.</para>
    
      <para>There may be arbitrarily many observer methods with the same event 
      parameter type and qualifiers.</para>
      
      <para>A bean (or extension) may declare multiple observer methods.</para>
      
    <section>
      <title>Event parameter of an observer method</title>
      
      <para>Each observer method must have exactly one <emphasis>event parameter</emphasis>,
      of the same type as the event type it observes. When searching for observer methods 
      for an event, the container considers the type and qualifiers of the event 
      parameter.</para>
      
      <para>If the event parameter does not explicitly declare any qualifier, the observer 
      method observes events with no qualifier.</para>
      
      <para>The event parameter type may contain a type variable or wildcard.</para>
      
    </section>
    
    <section id="observes">
      <title>Declaring an observer method</title>
      
      <para>An observer method may be declared by annotating a parameter 
      <literal>@javax.enterprise.event.Observes</literal> of a default-access, public, 
      protected or private method. That parameter is the event parameter. The declared type 
      of the parameter is the observed event type.</para>
      
      <programlisting>public void afterLogin(@Observes LoggedInEvent event) { ... }</programlisting>

      <para>If a method has more than one parameter annotated <literal>@Observes</literal>,
      the container automatically detects the problem and treats it as a definition 
      error.</para>
      
      <para>Observed event qualifiers may be declared by annotating the event parameter:</para>
      
      <programlisting>public void afterLogin(@Observes @Admin LoggedInEvent event) { ... }</programlisting>
 
      <para>If an observer method is annotated <literal>@Produces</literal>
      or <literal>@Inject</literal> or has a parameter annotated 
      <literal>@Disposes</literal>, the container automatically detects the problem 
      and treats it as a definition error.</para>
      
      <para>If a non-static method of a session bean class has a parameter annotated 
      <literal>@Observes</literal>, and the method is not a business method of the 
      EJB, the container automatically detects the problem and treats it as a 
      definition error.</para>
      
      <para>Interceptors and decorators may not declare observer methods. If an
      interceptor or decorator has a method with a parameter annotated <literal>@Observes</literal>,
      the container automatically detects the problem and treats it as a definition 
      error.</para>

      <para>In addition to the event parameter, observer methods may declare additional 
      parameters, which may declare qualifiers. These additional parameters are injection 
      points.</para>
      
      <programlisting>public void afterLogin(@Observes LoggedInEvent event, @Manager User user, Logger log) { ... }</programlisting>
      
    </section>
      
    <section>
      <title>Conditional observer methods</title>
      
      <para>A <emphasis>conditional observer method</emphasis> is an observer method which is notified
      of an event only if an instance of the bean that defines the observer method already exists in 
      the current context.</para>
      
      <para>A conditional observer method may be declared by specifying <literal>receive=IF_EXISTS</literal>.</para>
      
      <programlisting>public void refreshOnDocumentUpdate(@Observes(receive=IF_EXISTS) @Updated Document doc) { ... }</programlisting>
      
      <para>Beans with scope <literal>@Dependent</literal> may not have conditional observer methods.
      If a bean with scope <literal>@Dependent</literal> has an observer method declared
      <literal>receive=IF_EXISTS</literal>, the container automatically detects the problem and treats 
      it as a definition error.</para>
      
      <para>The enumeration <literal>javax.enterprise.event.Reception</literal> identifies the possible 
      values of <literal>receive</literal>:</para>
      
      <programlisting>public enum Reception { IF_EXISTS, ALWAYS }</programlisting>
          
    </section>
    
    <section>
      <title>Transactional observer methods</title>
      
      <para><emphasis>Transactional observer methods</emphasis> are observer methods which receive 
      event notifications during the before or after completion phase of the transaction in which the 
      event was fired. If no transaction is in progress when the event is fired, they are notified 
      at the same time as other observers.</para>
      
      <itemizedlist>
        <listitem>
          <para>A <emphasis>before completion</emphasis> observer method is called during the before 
          completion phase of the transaction.</para>
        </listitem>
        <listitem>
          <para>An <emphasis>after completion</emphasis> observer method is called during the after 
          completion phase of the transaction.</para>
        </listitem>
        <listitem>
          <para>An <emphasis>after success</emphasis> observer method is called during the after 
          completion phase of the transaction, only when the transaction completes 
          successfully.</para>
        </listitem>
        <listitem>
          <para>An <emphasis>after failure</emphasis> observer method is called during the after 
          completion phase of the transaction, only when the transaction fails.</para>
        </listitem>
      </itemizedlist>
      
      <para>The enumeration <literal>javax.enterprise.event.TransactionPhase</literal> identifies
      the kind of transactional observer method:</para>
      
      <programlisting>public enum TransactionPhase {
    IN_PROGRESS,
    BEFORE_COMPLETION,
    AFTER_COMPLETION,
    AFTER_FAILURE,
    AFTER_SUCCESS
}</programlisting>

      <para>A transactional observer method may be declared by specifying any value other than
      <literal>IN_PROGRESS</literal> for <literal>during</literal>:</para>
      
      <programlisting>void onDocumentUpdate(@Observes(during=AFTER_SUCCESS) @Updated Document doc) { ... }</programlisting>
                
    </section>
    
    </section>
    
    <section id="observernotification">
      <title>Observer notification</title>
    
      <para>When an event is fired by the application, the container must:</para>
      
      <itemizedlist>
        <listitem>
          <para>determine the observer methods for that event according to the rules of
          observer resolution defined by <xref linkend="observerresolution"/>, 
          then,</para>
        </listitem>
        <listitem>
          <para>for each observer method, either invoke the observer method immediately, 
          or register the observer method for later invocation during the transaction 
          completion phase, using a JTA <literal>Synchronization</literal>.</para>
        </listitem>
      </itemizedlist>
      
      <para>The container calls observer methods as defined in <xref linkend="observers"/>.</para>
      
      <itemizedlist>
        <listitem>
          <para>If the observer method is a transactional observer method and there is currently 
          a JTA transaction in progress, the container calls the observer method during the 
          appropriate transaction completion phase.</para>
        </listitem>
        <listitem>
          <para>If the observer method is a conditional observer method and there is no context 
          active for the scope to which the bean declaring the observer method belongs, then
          the observer method should not be called.</para>
        </listitem>
        <listitem>
          <para>Otherwise, the container calls the observer immediately.</para>
        </listitem>
      </itemizedlist>
      
      <para>The order in which observer methods are called is not defined, and so portable 
      applications should not rely upon the order in which observers are called.</para> 

      <para>Any observer method called before completion of a transaction may call 
      <literal>setRollbackOnly()</literal> to force a transaction rollback. An observer 
      method may not directly initiate, commit or rollback JTA transactions.</para>
    
      <para>Observer methods may throw exceptions:</para>
      
      <itemizedlist>
        <listitem>
           <para>If the observer method is a transactional observer method, any exception is caught 
           and logged by the container.</para>
        </listitem>
        <listitem>
           <para>Otherwise, the exception aborts processing of the event. No other observer methods 
           of that event will be called. The <literal>BeanManager.fireEvent()</literal> or
           <literal>Event.fire()</literal> method rethrows the exception. If the exception is a 
           checked exception, it is wrapped and rethrown as an (unchecked) 
           <literal>ObserverException</literal>.</para>
        </listitem>
      </itemizedlist>
    
      <para>For a custom implementation of the <literal>ObserverMethod</literal>
      interface defined in <xref linkend="observermethod"/>, the container must
      call <literal>getTransactionPhase()</literal> to determine if the observer
      method is transactional observer method, and <literal>notify()</literal> 
      to invoke the method.</para>
      
      <note>
         <para>CDI 1.1 implementations should call the <code>notify</code> method
         which takes both the event object and the event qualifiers only. The 
         <code>notify</code> method which takes only the event object is retained 
         only for backwards compatibility.</para>
      </note>
      
    <section>
      <title>Observer method invocation context</title>
      
      <para>The transaction context, client security context and lifecycle contexts active
      when an observer method is invoked depend upon what kind of observer method it is.</para>
      
      <itemizedlist>
        <listitem>
          <para>If the observer method is a before completion transactional observer method, it 
          is called within the context of the transaction that is about to complete and with the 
          same client security context and lifecycle contexts.</para>
        </listitem>
        <listitem>
          <para>Otherwise, if the observer method is any other kind of transactional observer method,
          it is called in an unspecified transaction context, but with the same client security
          context and lifecycle contexts as the transaction that just completed.</para>
        </listitem>
        <listitem>
          <para>Otherwise, the observer method is called in the same transaction context, client
          security context and lifecycle contexts as the invocation of <literal>Event.fire()</literal>
          or <literal>BeanManager.fireEvent()</literal>.</para>
        </listitem>
      </itemizedlist>
      
      <para>Of course, the transaction and security contexts for a business method of a session
      bean also depend upon the transaction attribute and <literal>@RunAs</literal> descriptor,
      if any.</para>
      
    </section>

    </section>
    
</chapter>

